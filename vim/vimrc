set guioptions=M

let g:is_windows = has('win32')

" Download vim-plug
if !g:is_windows && empty(glob($HOME . "/.vim/autoload/plug.vim"))
    :silent !mkdir -p ~/.vim/autoload >/dev/null 2>&1
    :silent !curl -fLo ~/.vim/autoload/plug.vim https://raw.github.com/junegunn/vim-plug/master/plug.vim >/dev/null 2>&1
endif

if exists("+undofile")
    if isdirectory($HOME . '/.vim/_undo') == 0
        :silent !mkdir -p ~/.vim/_undo > /dev/null 2>&1
    endif
    set undodir=./.vim-undo//,~/.vim/_undo//
    set undofile
endif

" Plug
call plug#begin('~/.vim/plugged')

" file management
Plug 'ctrlpvim/ctrlp.vim'
Plug 'FelikZ/ctrlp-py-matcher'
Plug 'tacahiroy/ctrlp-funky'
Plug 'justinmk/vim-dirvish'

" git
Plug 'tpope/vim-fugitive'

" textedit
Plug 'bronson/vim-trailing-whitespace'
Plug 'junegunn/vim-easy-align', { 'on': ['<Plug>(EasyAlign)', '<Plug>(LiveEasyAlign)'] }
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-rsi'
Plug 'michaeljsmith/vim-indent-object'
Plug 'coderifous/textobj-word-column.vim'

Plug 'w0rp/ale'

Plug 'tpope/vim-abolish', { 'on': ['S', '<Plug>Coerce'] }
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-projectionist'
if !g:is_windows
    Plug 'christoomey/vim-tmux-navigator'
    Plug 'jgdavey/tslime.vim'
endif

Plug 'joereynolds/vim-minisnip'

Plug 'ajh17/VimCompletesMe'

Plug 'tpope/vim-dispatch'
Plug 'janko-m/vim-test', { 'on': ['TestFile', 'TestLast', 'TestNearest', 'TestSuite', 'TestVisit'] }

Plug 'xuanduc987/matchit.zip'

" colorscheme
Plug 'xuanduc987/badwolf'
Plug 'nanotech/jellybeans.vim'
Plug 'bluz71/vim-moonfly-colors'
Plug 'romanzolotarev/vim-dark'
Plug 'albertorestifo/github.vim'

if filereadable(expand("~/.vimrc.lang.plug"))
    source ~/.vimrc.lang.plug
endif

if filereadable(expand("~/.vimplug.local"))
    source ~/.vimplug.local
endif

call plug#end()

" set
set autoindent
set backspace=indent,eol,start
set complete-=i                " don't scan included files
set nrformats-=octal
set incsearch
set laststatus=2
set ruler
set wildmenu
set scrolloff=1
set sidescrolloff=5
set display+=lastline
set formatoptions+=j " Delete comment character when joining commented lines
setglobal tags-=./tags tags-=./tags; tags^=./tags;
set autoread
set history=1000
set tabpagemax=50
if !empty(&viminfo)
    set viminfo^=!
endif
set sessionoptions-=options

if has('gui_running')
    set encoding=utf-8
endif

set textwidth=80
set nowrap
set colorcolumn=+1 " Color column textwidth + 1

set tabstop=4
set softtabstop=4
set shiftwidth=4
set shiftround
set expandtab
set smarttab

set hlsearch
set ignorecase " searches are case insensitive...
set smartcase " ... unless they contain at least one capital letter
set gdefault " use global flag by default

set belloff=all " no bell

set ambiwidth=double
set number
set mouse=n " Enable mouse support normal mode only

set ttyfast
set lazyredraw
set ttimeout timeout timeoutlen=800 ttimeoutlen=50
set synmaxcol=200

set nobackup
set noswapfile

" Natural split
set splitbelow
set splitright

" Special chars
set list " Show invisible characters
if (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8') && version >= 700
    let &listchars = "tab:»-,trail:⋅,extends:»,precedes:«"
else
    set listchars=tab:>\ ,trail:-,extends:>,precedes:<
endif

" Disable output and VCS files
set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem
" Disable archive files
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
" Ignore bundler and sass cache
set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
" Disable temp and backup files
set wildignore+=*.swp,*~,._*

" mapping
let mapleader = " "

nnoremap <leader>q :q<cr>

" 60% keyboard
nmap <leader>1 <F1>
nmap <leader>2 <F2>
nmap <leader>3 <F3>
nmap <leader>4 <F4>
nmap <leader>5 <F5>
nmap <leader>6 <F6>
nmap <leader>7 <F7>
nmap <leader>8 <F8>
nmap <leader>9 <F9>
nmap <leader>0 <F10>

" easy move between windows
nnore <silent> <C-K> :wincmd k<CR>
nnore <silent> <C-J> :wincmd j<CR>
nnore <silent> <C-H> :wincmd h<CR>
nnore <silent> <C-L> :wincmd l<CR>

" Adjust viewports to the same size
nore <Leader>= <C-w>=

" Toggle paste mode
nnore <silent> <F4> :set invpaste<CR>:set paste?<CR>
inore <silent> <F4> <ESC>:set invpaste<CR>:set paste?<CR>

" expand current directory
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
" expand home directory
cnoremap $$ <C-R>=fnameescape(expand('~')).'/'<cr>

" clear highlight
nnore <leader><CR> :noh<CR>

" In command-line mode, C-p use history to complete
cnoremap <C-P> <Up>

" replace last search
nnore s :%s//
xnore s :s//

" easy toogle case
inoremap <c-u> <esc>gUiwea

" Easy copy-paste
xnoremap <leader>y "+y
nnoremap <leader>y "+y
xnoremap <leader>p "+p
nnoremap <leader>p "+p

" Magic search
nnoremap /  /\v
nnoremap ?  ?\v

" unimpaired
function! s:MapNextFamily(map,cmd)
  let map = '<Plug>unimpaired'.toupper(a:map)
  let cmd = '".(v:count ? v:count : "")."'.a:cmd
  let end = '"<CR>'.(a:cmd == 'l' || a:cmd == 'c' ? 'zv' : '')
  execute 'nnoremap <silent> '.map.'Previous :<C-U>exe "'.cmd.'previous'.end
  execute 'nnoremap <silent> '.map.'Next     :<C-U>exe "'.cmd.'next'.end
  execute 'nnoremap <silent> '.map.'First    :<C-U>exe "'.cmd.'first'.end
  execute 'nnoremap <silent> '.map.'Last     :<C-U>exe "'.cmd.'last'.end
  execute 'nmap <silent> ['.        a:map .' '.map.'Previous'
  execute 'nmap <silent> ]'.        a:map .' '.map.'Next'
  execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'
  execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'
  if exists(':'.a:cmd.'nfile')
    execute 'nnoremap <silent> '.map.'PFile :<C-U>exe "'.cmd.'pfile'.end
    execute 'nnoremap <silent> '.map.'NFile :<C-U>exe "'.cmd.'nfile'.end
    execute 'nmap <silent> [<C-'.a:map.'> '.map.'PFile'
    execute 'nmap <silent> ]<C-'.a:map.'> '.map.'NFile'
  endif
endfunction

call s:MapNextFamily('a','')
call s:MapNextFamily('b','b')
call s:MapNextFamily('l','l')
call s:MapNextFamily('q','c')
call s:MapNextFamily('t','t')

" insert blank line
nnoremap [<space>     :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[
nnoremap ]<space>     :<c-u>put =repeat(nr2char(10), v:count1)<cr>

" swap line
nnoremap [e           :<c-u>execute 'move -1-'. v:count1<cr>
nnoremap ]e           :<c-u>execute 'move +'. v:count1<cr>

" toogle quickfix/location list
function! GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction

function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction

nmap <silent> <leader>c :call ToggleList("Quickfix List", 'c')<CR>
nmap <silent> <leader>l :call ToggleList("Location List", 'l')<CR>

" change cursor shape for urxvt, xterm,...
if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>[6 q\<Esc>\\"
    let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>[4 q\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>[2 q\<Esc>\\"
elseif !g:is_windows
    let &t_SI = "\<Esc>[6 q"
    let &t_SR = "\<Esc>[4 q"
    let &t_EI = "\<Esc>[2 q"
endif

" autocmd
augroup vimrc
    autocmd!

    " Remember last location in file, but not for commit messages.
    " see :help last-position-jump
    au BufReadPost * if &filetype !~ '^git\c' && line("'\"") > 0 && line("'\"") <= line("$")
                \| exe "normal! g`\"" | endif

    au FileType qf call AdjustWindowHeight(3, 15)
    " Auto adjust quickfix window
    function! AdjustWindowHeight(minheight, maxheight)
      exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
    endfunction

    au FileType liquid,markdown setlocal linebreak nolist spell
augroup END

" statusline
set statusline =%!MyStatusLine()

function! MyStatusLine()
  let stl = '%m'                            " modified flag
  let stl .= ' »'
  let stl .= ' %f'                          " Relative path to file
  let stl .= ' «'
  let stl .= ' %h'                          " [help]
  let stl .= '%r'                           " read only flag
  let stl .= '%w'                           " preview window flag
  let stl .= '%y'                           " filetype
  let stl .= '%='
  let stl .= '['.&fileencoding.']  '
  let stl .= '%-8(%l,%c%V%)'                " Line, column-virtual column
  let stl .= ' %6P'

  if exists('b:git_dir')
    let stl .= ' ← '
    let branch = fugitive#head(8)
    let stl .= (branch == 'master') ? '%#ErrorMsg#master%*' : branch
  endif
  return stl
endfunction

function! SudoWrite()
    write !sudo tee %
    " Or with :silent (but that doesn't seem to work for everyone)
    "silent write !sudo tee %
    edit!
endfun

command SudoWrite call SudoWrite()

" plugin settings
" disable builtins
let g:loaded_logipat = 1
let g:loaded_tarPlugin = 1
let g:loaded_tar       = 1
let loaded_gzip        = 1
let g:loaded_zipPlugin = 1
let g:loaded_zip       = 1
let g:loaded_vimballPlugin = 1
let g:loaded_vimball       = 1
let g:loaded_netrw       = 1
let g:loaded_netrwPlugin = 1

" snippet
let g:minisnip_trigger = '<C-j>'

" Abolist
nmap cr <Plug>Coerce

" Tslime
if !g:is_windows
    let g:tslime_always_current_session = 1
    let g:tslime_always_current_window = 1
    vmap <C-c><C-c> <Plug>SendSelectionToTmux
    nmap <C-c><C-c> <Plug>NormalModeSendToTmux
    nmap <C-c>r <Plug>SetTmuxVars
endif

" vim-test
nmap <silent> <leader>t :TestNearest<CR>
nmap <silent> <leader>T :TestFile<CR>
nmap <silent> <leader>a :TestSuite<CR>
nmap <silent> <leader>L :TestLast<CR>
nmap <silent> <leader>g :TestVisit<CR>
let test#strategy = "dispatch"

" ctrlp setting
let g:ctrlp_map = ''
nore <c-p> :CtrlP<CR>
nore <Leader>b :CtrlPBuffer<CR>
nore <Leader>; :CtrlPTag<CR>
nore <Leader>, :CtrlPBufTag<CR>
nore <Leader>. :CtrlPFunky<CR>
let g:ctrlp_clear_cache_on_exit = 0
if has('python')
    let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif
let g:ctrlp_custom_ignore = {
            \ 'dir': '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\.pyc$\|\.pyo$\|\.rbc$|\.rbo$\|\.class$\|\.o$\|\~$\',
            \ }
" If ag is available use it as filename list generator instead of 'find'
if executable("ag")
    set grepprg=ag\ --nogroup\ --nocolor
    let g:ctrlp_user_command = 'ag -i --nocolor --nogroup
                \ --ignore ".git"
                \ --ignore ".svn"
                \ --ignore ".DS_Store"
                \ --ignore "node_modules"
                \ --hidden -g "" %s'
endif

" EasyAlign
xmap <CR> <Plug>(EasyAlign)

" Dispatch
nnoremap <leader>d :Dispatch<space>

" read .vimrc.local
if filereadable(expand("~/.vimrc.local"))
    source ~/.vimrc.local
endif
