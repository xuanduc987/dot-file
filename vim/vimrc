" init {{{1
let g:is_windows = has('win32')

" Download vim-plug {{{2
if !g:is_windows && empty(glob($HOME . "/.vim/autoload/plug.vim"))
    :silent !mkdir -p ~/.vim/autoload >/dev/null 2>&1
    :silent !curl -fLo ~/.vim/autoload/plug.vim https://raw.github.com/junegunn/vim-plug/master/plug.vim >/dev/null 2>&1
endif

" Create folder for vimfinfo, swap, undo... {{{2
if isdirectory($HOME . '/.vim/_temp') == 0
    :silent !mkdir -p ~/.vim/_temp >/dev/null 2>&1
endif
set directory=./.vim-swap//
set directory+=~/.vim/_temp//
set directory+=~/tmp//
set directory+=.

if has('nvim')
    set viminfo+=n~/.config/nvim/nvim.shada
else
    set viminfo+=n~/.vim/viminfo
endif

if exists("+undofile")
    if isdirectory($HOME . '/.vim/_undo') == 0
        :silent !mkdir -p ~/.vim/_undo > /dev/null 2>&1
    endif
    set undodir=./.vim-undo//
    set undodir+=~/.vim/_undo//
    set undofile
endif

" Plug {{{1
call plug#begin('~/.vim/plugged')

" file management
Plug 'ctrlpvim/ctrlp.vim' | Plug 'FelikZ/ctrlp-py-matcher'
Plug 'tpope/vim-eunuch'
Plug 'justinmk/vim-dirvish'

" git
Plug 'tpope/vim-fugitive'

" textedit
Plug 'AndrewRadev/splitjoin.vim'
Plug 'jiangmiao/auto-pairs'
Plug 'bronson/vim-trailing-whitespace'
Plug 'junegunn/vim-easy-align', { 'on': '<Plug>(LiveEasyAlign)' }
Plug 'haya14busa/incsearch.vim', { 'on': ['<Plug>(incsearch-forward)', '<Plug>(incsearch-backward)', '<Plug>(incsearch-stay)'] }
Plug 'tpope/vim-commentary'
Plug 'conradirwin/vim-bracketed-paste'
Plug 'tpope/vim-rsi'

Plug '907th/vim-auto-save'

Plug 'tpope/vim-sleuth'
Plug 'sjl/gundo.vim', {'on': 'GundoToggle'}
Plug 'tpope/vim-abolish', { 'on': 'S' }
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-projectionist'
Plug 'tpope/vim-haystack'
Plug 'mattn/emmet-vim', { 'for': ['html', 'haml', 'eruby'] }
if !g:is_windows
    Plug 'christoomey/vim-tmux-navigator'
    Plug 'jgdavey/tslime.vim'
    Plug 'vim-scripts/fcitx.vim', { 'on': [] }
endif

Plug 'MarcWeber/vim-addon-mw-utils' | Plug 'tomtom/tlib_vim' | Plug 'garbas/vim-snipmate'

Plug 'tpope/vim-dispatch'
Plug 'benekastah/neomake', { 'on': ['Neomake'] }
Plug 'janko-m/vim-test', { 'on': ['TestFile', 'TestLast', 'TestNearest', 'TestSuite', 'TestVisit'] }

Plug 'tpope/vim-rails', { 'for': ['ruby', 'haml', 'eruby'] }

Plug 'ternjs/tern_for_vim'

Plug 'leafgarland/typescript-vim'

Plug 'xuanduc987/matchit.zip'

" colorscheme
Plug 'xuanduc987/badwolf'
Plug 'nanotech/jellybeans.vim'

if filereadable(expand("~/.vimplug.local"))
    source ~/.vimplug.local
endif
call plug#end()

" set {{{1
" sensible {{{2
set autoindent
set backspace=indent,eol,start
set complete-=i
set smarttab

set nrformats-=octal

set ttimeout

set incsearch

set laststatus=2
set ruler
set wildmenu
set lazyredraw

set scrolloff=1
set sidescrolloff=5
set display+=lastline

if &encoding ==# 'latin1' && has('gui_running')
    set encoding=utf-8
endif

if v:version > 703 || v:version == 703 && has("patch541")
    set formatoptions+=j " Delete comment character when joining commented lines
endif

if has('path_extra')
    setglobal tags-=./tags tags-=./tags; tags^=./tags;
endif

set autoread

if &history < 1000
    set history=1000
endif
if &tabpagemax < 50
    set tabpagemax=50
endif
if !empty(&viminfo)
    set viminfo^=!
endif
set sessionoptions-=options

" Allow color schemes to do bright colors without forcing bold.
if &t_Co == 8 && $TERM !~# '^linux\|^Eterm'
    set t_Co=16
endif

" Load matchit.vim, but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
    runtime! macros/matchit.vim
endif

" other{{{2
let mapleader = " "
set nowrap " don't wrap lines
set tabstop=8
set softtabstop=2 " a tab is two spaces
set shiftwidth=2 " an autoindent (with <<) is two spaces
set shiftround
set expandtab " use spaces, not tabs
set list " Show invisible characters
set hlsearch " highlight matches
set ignorecase " searches are case insensitive...
set smartcase " ... unless they contain at least one capital letter

set number

set modeline

set mouse=n " Enable mouse support
set cc=+1 " Color column textwidth + 1

set ttyfast
set timeout timeoutlen=800 ttimeoutlen=50
set synmaxcol=300

set textwidth=80

set formatoptions-=o   " Don't insert comment leader when press o or O in normal mode

" Natural split
set splitbelow
set splitright

" Special chars
if (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8') && version >= 700
    let &listchars = "tab:▸\ ,trail:·,extends:»,precedes:«,nbsp:\u26ad"
    let &fillchars = "vert:│,fold:·"
else
    set listchars=tab:>\ ,trail:-,extends:>,precedes:<
endif

" Some options for neovim
if has('nvim')
  let g:python3_host_skip_check = 1
  let g:python_host_skip_check = 1
endif

" Disable output and VCS files
set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem
" Disable archive files
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
" Ignore bundler and sass cache
set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
" Disable temp and backup files
set wildignore+=*.swp,*~,._*

" mapping {{{1
" easy move between windows
nnore <silent> <C-K> :wincmd k<CR>
nnore <silent> <C-J> :wincmd j<CR>
nnore <silent> <C-H> :wincmd h<CR>
nnore <silent> <C-L> :wincmd l<CR>

" Adjust viewports to the same size
nore <Leader>= <C-w>=

" Toggle paste mode
nnore <silent> <F4> :set invpaste<CR>:set paste?<CR>
inore <silent> <F4> <ESC>:set invpaste<CR>:set paste?<CR>

" Some helpers to edit mode
" http://vimcasts.org/e/14
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>

" expand home directory
cnoremap $$ <C-R>=fnameescape(expand('~')).'/'<cr>

" Map the arrow keys to be based on display lines, not physical lines
nore <Down> gj
nore <Up> gk

" clear highlight
nnore <leader><CR> :noh<CR>

" In command-line mode, C-p use history to complete
cnoremap <C-P> <Up>

" C-O in insert mode to create and jump to newline
inoremap <C-O> <C-O>o

" replace last search
nnore s :%s///g<Left><Left>
xnore s :s///g<Left><Left>

" find merge conflict markers
nnore <silent> <leader>fc <ESC>/\v^[<=>]{7}( .*\|$)<CR>

" easy toogle case
inoremap <c-u> <esc>gUiwea
inoremap <c-`> <esc>g~iwea

" Easy copy-paste
xnoremap <leader>y "+y
nnoremap <leader>y "+Y
nnoremap <c-p> "+p

" unimpaired {{{3
function! s:MapNextFamily(map,cmd)
  let map = '<Plug>unimpaired'.toupper(a:map)
  let cmd = '".(v:count ? v:count : "")."'.a:cmd
  let end = '"<CR>'.(a:cmd == 'l' || a:cmd == 'c' ? 'zv' : '')
  execute 'nnoremap <silent> '.map.'Previous :<C-U>exe "'.cmd.'previous'.end
  execute 'nnoremap <silent> '.map.'Next     :<C-U>exe "'.cmd.'next'.end
  execute 'nnoremap <silent> '.map.'First    :<C-U>exe "'.cmd.'first'.end
  execute 'nnoremap <silent> '.map.'Last     :<C-U>exe "'.cmd.'last'.end
  execute 'nmap <silent> ['.        a:map .' '.map.'Previous'
  execute 'nmap <silent> ]'.        a:map .' '.map.'Next'
  execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'
  execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'
  if exists(':'.a:cmd.'nfile')
    execute 'nnoremap <silent> '.map.'PFile :<C-U>exe "'.cmd.'pfile'.end
    execute 'nnoremap <silent> '.map.'NFile :<C-U>exe "'.cmd.'nfile'.end
    execute 'nmap <silent> [<C-'.a:map.'> '.map.'PFile'
    execute 'nmap <silent> ]<C-'.a:map.'> '.map.'NFile'
  endif
endfunction

call s:MapNextFamily('a','')
call s:MapNextFamily('b','b')
call s:MapNextFamily('l','l')
call s:MapNextFamily('q','c')
call s:MapNextFamily('t','t')

" insert blank line
nnoremap [<space>     :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[
nnoremap ]<space>     :<c-u>put =repeat(nr2char(10), v:count1)<cr>

" swap line
nnoremap [e           :<c-u>execute 'move -1-'. v:count1<cr>
nnoremap ]e           :<c-u>execute 'move +'. v:count1<cr>

" switch comma-separated arguments
function! SwitchNext()
  let s=&isk
  setl isk+=\",'
  normal diwmmebgPdw`mP
  let &isk=s
endfunction

nmap     [w          F,h]w2w
nnoremap <silent> ]w @=SwitchNext()<CR>

" toogle quickfix/location list {{{3
function! GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction

function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction

nmap <silent> <leader>c :call ToggleList("Quickfix List", 'c')<CR>
nmap <silent> <leader>l :call ToggleList("Location List", 'l')<CR>

" change cursor shape for urxvt, xterm,... {{{3
if has('nvim')
    let $NVIM_TUI_ENABLE_CURSOR_SHAPE = 1
elseif v:version > 704 || v:version == 704 && has('patch687')
    if exists('$TMUX')
        let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>[6 q\<Esc>\\"
        let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>[4 q\<Esc>\\"
        let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>[2 q\<Esc>\\"
    elseif !g:is_windows
        let &t_SI = "\<Esc>[6 q"
        let &t_SR = "\<Esc>[4 q"
        let &t_EI = "\<Esc>[2 q"
    endif
endif
" autocmd{{{1
augroup vimrc
    autocmd!

    " Remember last location in file, but not for commit messages.
    " see :help last-position-jump
    au BufReadPost * if &filetype !~ '^git\c' && line("'\"") > 0 && line("'\"") <= line("$")
                \| exe "normal! g`\"" | endif

    au FileType qf call AdjustWindowHeight(3, 15)
    " Auto adjust quickfix window
    function! AdjustWindowHeight(minheight, maxheight)
      exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
    endfunction

    au FileType liquid,markdown,
          \ setlocal tw=80 linebreak nolist spell
augroup END

" statusline{{{1
set statusline =%!MyStatusLine()

function! MyStatusLine()
  let stl = '%m'                            " modified flag
  let stl .= ' »'
  let stl .= ' %f'                          " Relative path to file
  let stl .= ' «'
  let stl .= ' %h'                          " [help]
  let stl .= '%r'                           " read only flag
  let stl .= '%w'                           " preview window flag
  let stl .= '%y'                           " filetype
  let stl .= '%='
  let stl .= '['.&fileencoding.']  '
  let stl .= '%-8(%l,%c%V%)'                " Line, column-virtual column
  let stl .= ' %6P'

  if exists('b:git_dir')
    let stl .= ' ← '
    let branch = fugitive#head(8)
    let stl .= (branch == 'master') ? '%#ErrorMsg#master%*' : branch
  endif
  return stl
endfunction

" plugin settings {{{1
" disable buildins {{{2
let g:loaded_logipat       = 1

let g:loaded_tarPlugin     = 1
let g:loaded_tar           = 1

let loaded_gzip            = 1

let g:loaded_zipPlugin     = 1
let g:loaded_zip           = 1

let g:loaded_vimballPlugin = 1
let g:loaded_vimball       = 1

let g:loaded_netrw       = 1
let g:loaded_netrwPlugin = 1

" snippet {{{2
autocmd! CompleteDone * let g:forward_complete = 1
let g:forward_complete = 1

function! g:My_Complete()
    if pumvisible()
        return g:forward_complete ? "\<C-n>" : "\<C-p>"
    else
        if s:WillComplete()
            let g:forward_complete = 0
            return "\<C-p>"
        else
            return "\<TAB>"
        endif
    endif
endfunction

function! s:WillComplete()
    let line = getline('.')
    let cnum = col('.') - 1
    let post = line[cnum - 1:]

    for pattern in ['$', '\s', '[(){}\[\]]']
        if post =~ '^' . pattern
            return 0
        endif
    endfor

    return 1
endfunction

function! g:WrapOmni()
    let g:forward_complete = 1
    return "\<C-X>\<C-O>\<C-P>"
endfunction

let g:SuperTabMappingForward = "<tab>"
imap <silent> <Plug>SuperTabForward <C-R>=g:My_Complete()<cr>
imap <tab> <Plug>snipMateTrigger
imap <C-J> <Plug>snipMateNextOrTrigger

inoremap <expr> <C-X><C-O> g:WrapOmni()

imap <Nul> <C-Space>
inoremap <expr> <C-Space> g:WrapOmni()

let g:snipMate = {}
let g:snipMate.snippet_version = 1

" Fcitx {{{2
command! Fcitx :call plug#load('fcitx.vim')

" incsearch.vim {{{2
nmap /  <Plug>(incsearch-forward)\v
nmap ?  <Plug>(incsearch-backward)\v
nmap g/ <Plug>(incsearch-stay)\v

" Tslime {{{2
let g:tslime_always_current_session = 1
let g:tslime_always_current_window = 1
vmap <C-c><C-c> <Plug>SendSelectionToTmux
nmap <C-c><C-c> <Plug>NormalModeSendToTmux
nmap <C-c>r <Plug>SetTmuxVars

" Neomake {{{2
autocmd! BufWritePost * Neomake
if !has('nvim')
    let g:neomake_ruby_enabled_makers = ['mri']
endif

" vim-test {{{2
nmap <silent> <leader>t :TestNearest<CR>
nmap <silent> <leader>T :TestFile<CR>
nmap <silent> <leader>a :TestSuite<CR>
nmap <silent> <leader>L :TestLast<CR>
nmap <silent> <leader>g :TestVisit<CR>
let test#strategy = "dispatch"

" ctrlp setting {{{2
let g:ctrlp_map = ''
nore <Leader>p :CtrlP<CR>
nore <Leader>b :CtrlPBuffer<CR>
nore <Leader>; :CtrlPTag<CR>
nore <Leader>, :CtrlPBufTag<CR>
let g:ctrlp_clear_cache_on_exit = 0
if has('python')
    let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif
let g:ctrlp_custom_ignore = {
            \ 'dir': '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\.pyc$\|\.pyo$\|\.rbc$|\.rbo$\|\.class$\|\.o$\|\~$\',
            \ }
" If ag is available use it as filename list generator instead of 'find'
if executable("ag")
    set grepprg=ag\ --nogroup\ --nocolor
    let g:ctrlp_user_command = 'ag -i --nocolor --nogroup
                \ --ignore ''.git''
                \ --ignore ''.DS_Store''
                \ --ignore ''node_modules''
                \ --ignore ''vendor/plugins''
                \ --hidden -g "" %s'
    let g:ctrlp_use_caching = 0
endif

" gundo {{{2
nnore <F5> :GundoToggle<CR>
inore <F5> <ESC>:GundoToggle<CR>

" git fugitive {{{2
nnore <leader>gb :Gblame<CR>
nnore <leader>gg :Ggrep <C-R><C-W><CR>

" split join {{{2
let g:splitjoin_split_mapping = ''
let g:splitjoin_join_mapping = ''
nmap <Leader>j :SplitjoinJoin<cr>
nmap <Leader>s :SplitjoinSplit<cr>

" EasyAlign {{{2
xmap <CR> <Plug>(LiveEasyAlign)

" vim-rails {{{2
let g:rails_projections = {
    \          "app/decorators/*_decorator.rb": {
    \              "command": "decorator",
    \              "affinity": "model",
    \              "test": "spec/decorators/%s_spec.rb",
    \              "related": "app/models/%s.rb",
    \              "template": "class %SDecorator < Draper::Decorator\nend"
    \          },
    \          "test/factories/*.rb": {
    \              "command":   "factory",
    \              "affinity":  "collection",
    \              "alternate": "app/models/{singular}.rb",
    \              "related":   "db/schema.rb#{}",
    \              "test":          "test/models/{singular}_test.rb",
    \              "template":  "FactoryGirl.define do\n  factory :{singular} do\n  end\nend",
    \              "keywords":  "factory sequence"
    \          },
    \          "spec/factories/*.rb": {
    \              "command":   "factory",
    \              "affinity":  "collection",
    \              "alternate": "app/models/{singular}.rb",
    \              "related":   "db/schema.rb#{}",
    \              "test":          "spec/models/{singular}_test.rb",
    \              "template":  "FactoryGirl.define do\n  factory :{singular} do\n  end\nend",
    \              "keywords":  "factory sequence"
    \          }
    \ }

" emmet {{{2
imap <C-K> <C-Y>,
imap <C-n> <C-Y>n
imap <C-p> <C-Y>N

" Dispatch {{{2
nnoremap <leader>d :Dispatch<space>

" Auto save {{{2
let g:auto_save = 1

" colors {{{1
if !exists('g:colors_name')
    let g:jellybeans_use_term_italics = 1
    colorscheme jellybeans
endif
"}}}

" Ruby completion {{{1
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_rails = 1

" read .vimrc.local {{{1
if filereadable(expand("~/.vimrc.local"))
    source ~/.vimrc.local
endif

" vim: ts=8 sts=4 sw=4 fdm=marker
