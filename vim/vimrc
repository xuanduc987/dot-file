set guioptions=M

let g:is_windows = has('win32')

if exists("+undofile")
    if isdirectory($HOME . '/.vim/_undo') == 0 && !g:is_windows
        :silent !mkdir -p ~/.vim/_undo > /dev/null 2>&1
    endif
    set undodir=./.vim-undo//,~/.vim/_undo//
    set undofile
endif

" Plug
call plug#begin('~/.vim/plugged')

" file management
Plug 'ctrlpvim/ctrlp.vim'
Plug 'justinmk/vim-dirvish'

Plug 'bronson/vim-trailing-whitespace'
Plug 'junegunn/vim-easy-align', { 'on': ['<Plug>(EasyAlign)'] }
Plug 'tomtom/tcomment_vim'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
if !g:is_windows
    Plug 'christoomey/vim-tmux-navigator'
    Plug 'benmills/vimux'
endif
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'tomtom/tlib_vim'
Plug 'garbas/vim-snipmate'

Plug 'romainl/vim-qf'

Plug 'janko-m/vim-test', { 'on': ['TestFile', 'TestLast', 'TestNearest', 'TestSuite', 'TestVisit'] }

Plug 'sgur/vim-editorconfig'
Plug 'ludovicchabant/vim-gutentags'

Plug 'mattn/emmet-vim'
Plug 'jiangmiao/auto-pairs'

Plug 'natebosch/vim-lsc'
Plug 'lifepillar/vim-mucomplete'

Plug 'pangloss/vim-javascript'
Plug 'HerringtonDarkholme/yats.vim'
Plug 'MaxMEllon/vim-jsx-pretty'
Plug 'styled-components/vim-styled-components', { 'branch': 'main' }
Plug 'LnL7/vim-nix'

Plug 'cormacrelf/vim-colors-github'
Plug 'rhysd/vim-color-spring-night'

if filereadable(expand("~/.vimplug.local"))
    source ~/.vimplug.local
endif

call plug#end()

" set
set autoindent
set backspace=indent,eol,start
set nrformats-=octal
set incsearch
set laststatus=2
set showcmd
set wildmenu
set scrolloff=1 sidescrolloff=5
set display+=lastline
set formatoptions+=j " Delete comment character when joining commented lines
setglobal tags-=./tags tags-=./tags; tags^=./tags;
set autoread
set history=1000
if !empty(&viminfo)
    set viminfo^=!
endif

set encoding=utf-8

set textwidth=80
set nowrap
set colorcolumn=+1 " Color column textwidth + 1

set shiftwidth=4
set expandtab
set smarttab

set hlsearch
set ignorecase " searches are case insensitive...
set smartcase " ... unless they contain at least one capital letter
set gdefault " use global flag by default

set belloff=all " no bell

set ambiwidth=single
set mouse=n " Enable mouse support normal mode only

set ttyfast
set lazyredraw
set ttimeout timeout timeoutlen=800 ttimeoutlen=50
set synmaxcol=400

set nobackup noswapfile

" Natural split
set splitbelow
set splitright

set list " Show special characters for inivisible chars
if (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8') && version >= 700
    let &listchars = "tab:»-,trail:⋅,extends:»,precedes:«"
    set fillchars=vert:│
else
    set listchars=tab:>\ ,trail:-,extends:>,precedes:<
endif

set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem,*.swp,*~,._*

" mapping
let mapleader = " "

nnoremap <leader>q :q<cr>
nnoremap <leader>w :update<CR>
nnoremap <leader>f :grep<space>
nnoremap <leader>vs :vsplit <C-R>=fnameescape(expand('%:h')).'/'<cr>
nnoremap <leader>xs :split <C-R>=fnameescape(expand('%:h')).'/'<cr>

" calculator
xnoremap <leader>r c<C-R>=<C-R>"<CR><esc>

" easy move between windows
nnore <silent> <C-K> :wincmd k<CR>
nnore <silent> <C-J> :wincmd j<CR>
nnore <silent> <C-H> :wincmd h<CR>
nnore <silent> <C-L> :wincmd l<CR>

" Adjust viewports to the same size
nore <Leader>= <C-w>=

" Toggle paste mode
nmap <leader>4 <F4>
nnore <silent> <F4> :set invpaste<CR>:set paste?<CR>
inore <silent> <F4> <ESC>:set invpaste<CR>:set paste?<CR>
set pastetoggle=<F4>

" expand current directory
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
" expand home directory
cnoremap $$ <C-R>=fnameescape(expand('~')).'/'<cr>

" clear highlight
nnore <leader><CR> :noh<CR>

" In command-line mode, C-p use history to complete
cnoremap <C-P> <Up>

" replace last search
nnore s :%s//
xnore s :s//

" easy upper case
inoremap <c-u> <left><c-o>:normal gUiwea<CR><right>

" Easy copy-paste
xnoremap <leader>y "+y
nnoremap <leader>y "+y
xnoremap <leader>p "+p
nnoremap <leader>p "+p

" Magic search
nnoremap /  /\v
nnoremap ?  ?\v

" copy from unimpaired
function! s:MapNextFamily(map,cmd)
  let map = '<Plug>unimpaired'.toupper(a:map)
  let cmd = '".(v:count ? v:count : "")."'.a:cmd
  let end = '"<CR>'.(a:cmd == 'l' || a:cmd == 'c' ? 'zv' : '')
  execute 'nnoremap <silent> '.map.'Previous :<C-U>exe "'.cmd.'previous'.end
  execute 'nnoremap <silent> '.map.'Next     :<C-U>exe "'.cmd.'next'.end
  execute 'nnoremap <silent> '.map.'First    :<C-U>exe "'.cmd.'first'.end
  execute 'nnoremap <silent> '.map.'Last     :<C-U>exe "'.cmd.'last'.end
  execute 'nmap <silent> ['.        a:map .' '.map.'Previous'
  execute 'nmap <silent> ]'.        a:map .' '.map.'Next'
  execute 'nmap <silent> ['.toupper(a:map).' '.map.'First'
  execute 'nmap <silent> ]'.toupper(a:map).' '.map.'Last'
  if exists(':'.a:cmd.'nfile')
    execute 'nnoremap <silent> '.map.'PFile :<C-U>exe "'.cmd.'pfile'.end
    execute 'nnoremap <silent> '.map.'NFile :<C-U>exe "'.cmd.'nfile'.end
    execute 'nmap <silent> [<C-'.a:map.'> '.map.'PFile'
    execute 'nmap <silent> ]<C-'.a:map.'> '.map.'NFile'
  endif
endfunction

call s:MapNextFamily('a','')
call s:MapNextFamily('b','b')
call s:MapNextFamily('l','l')
call s:MapNextFamily('q','c')
call s:MapNextFamily('t','t')

" insert blank line
nnoremap [<space>     :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[
nnoremap ]<space>     :<c-u>put =repeat(nr2char(10), v:count1)<cr>

" toogle quickfix/location list
function! GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction

function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction

nnoremap <silent> <leader>c :call ToggleList("Quickfix List", 'c')<CR>
nnoremap <silent> <leader>l :call ToggleList("Location List", 'l')<CR>
nnoremap <silent> <leader>z :pclose<CR>

" change cursor shape for urxvt, xterm,...
if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>[6 q\<Esc>\\"
    let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>[4 q\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>[2 q\<Esc>\\"
elseif !g:is_windows
    let &t_SI = "\<Esc>[6 q"
    let &t_SR = "\<Esc>[4 q"
    let &t_EI = "\<Esc>[2 q"
endif

" autocmd
augroup vimrc
    autocmd!

    " Remember last location in file, but not for commit messages.
    " see :help last-position-jump
    au BufReadPost * if &filetype !~ '^git\c' && line("'\"") > 0 && line("'\"") <= line("$")
                \| exe "normal! g`\"" | endif
augroup END

" User ag if possible
if executable("ag")
    set grepprg=ag\ --nogroup\ --nocolor\ --path-to-ignore\ ~/.ignore
endif

" statusline
set statusline=%m                      " modified flag
set statusline+=\ \                    " separator
set statusline+=%f                     " Relative path to file
set statusline+=\ \                    " separator
set statusline+=%h                     " [help]
set statusline+=%r                     " read only flag
set statusline+=%w                     " preview window flag
set statusline+=%y                     " filetype
set statusline+=%=
set statusline+=[%{&fileencoding}]\ \  " file encoding
set statusline+=%-8(%l,%c%V%)          " Line, column-virtual column
set statusline+=\ %6P

if !g:is_windows
    function! SudoWrite()
        write !sudo tee %
        edit!
    endfun

    command! SudoWrite call SudoWrite()
endif

" plugin settings
" disable built-ins
let g:loaded_logipat       = 1
let g:loaded_tarPlugin     = 1
let g:loaded_tar           = 1
let g:loaded_gzip          = 1
let g:loaded_zipPlugin     = 1
let g:loaded_zip           = 1
let g:loaded_vimballPlugin = 1
let g:loaded_vimball       = 1
let g:loaded_netrw         = 1
let g:loaded_netrwPlugin   = 1

" snippet
imap <C-J> <Plug>snipMateNextOrTrigger
smap <C-J> <Plug>snipMateNextOrTrigger
" fallback to emmet
let g:snipMate = {
      \ 'no_match_completion_feedkeys_chars': "\<c-y>,"
      \}
xmap <C-J> <C-Y>,

" Tslime
if !g:is_windows
    let g:tslime_always_current_session = 1
    let g:tslime_always_current_window = 1
    vmap <C-c><C-c> <Plug>SendSelectionToTmux
    nmap <C-c><C-c> <Plug>NormalModeSendToTmux
    nmap <C-c>r <Plug>SetTmuxVars
endif

" ctrlp
let g:ctrlp_map = ''
nnore <Leader>o :CtrlP<CR>
nnore <Leader>b :CtrlPBuffer<CR>
nnore <Leader>; :CtrlPTag<CR>
nnore <Leader>, :CtrlPBufTag<CR>

let g:ctrlp_use_caching = 1
let g:ctrlp_clear_cache_on_exit = 1
let g:ctrlp_custom_ignore = {
            \ 'dir': '\v[\/]\.(git|hg|svn)$',
            \ 'file': '\.pyc$\|\.pyo$\|\.rbc$|\.rbo$\|\.class$\|\.o$\|\~$\',
            \ }

" If ag is available use it as filename list generator instead of 'find'
if executable("ag")
  let g:ctrlp_user_command = 'ag -i --nocolor --nogroup
        \ --ignore ".git" --ignore ".svn"
        \ --ignore ".DS_Store" --ignore "node_modules"
        \ --path-to-ignore "~/.ignore"
        \ --hidden -g "" %s'
endif

" language server
function! s:findRoot(marker, ...) abort
  let l:path = a:0 > 1 ? a:1 : expand('%')
  let l:fullPath = fnamemodify(l:path, ':p')
  let l:dir = l:fullPath

  while 1
    " go up 1 lvel
    let l:dir = fnamemodify(l:dir, ':h')
    if l:dir == '/'
      return ''
    endif
    let l:filename = l:dir.'/'.a:marker
    if filereadable(l:filename) || isdirectory(l:filename)
      return l:dir
    endif
  endwhile
endfunction

function! s:getJsLsp() abort
  let l:pkgRoot = s:findRoot('package.json')
  if filereadable(l:pkgRoot.'/.flowconfig')
    " flow prj
    let l:flowbinRoot = s:findRoot('node_modules/.bin/flow', l:pkgRoot)
    if !empty(l:flowbinRoot)
      return l:flowbinRoot.'/node_modules/.bin/flow lsp --from vim'
    endif
  endif
  return 'typescript-language-server --stdio'
endfunction
let g:lsc_auto_map = {'defaults': v:true}
let g:lsc_server_commands = {
  \ 'javascript': s:getJsLsp(),
  \ 'javascript.jsx': s:getJsLsp(),
  \ 'typescript': s:getJsLsp(),
  \ 'typescript.tsx': s:getJsLsp()
  \}

" vim-test
nnoremap <silent> <leader>tt :TestNearest<CR>
nnoremap <silent> <leader>tf :TestFile<CR>
nnoremap <silent> <leader>ta :TestSuite<CR>
nnoremap <silent> <leader>tl :TestLast<CR>
nnoremap <silent> <leader>tg :TestVisit<CR>
let test#strategy = 'vimux'
let g:test#javascript#jest#file_pattern = '\v((/__tests__/.*)|((\.|/)(test|spec)))\.[jt]sx?$'

" EasyAlign
xmap <CR> <Plug>(EasyAlign)

" complete
let g:mucomplete#enable_auto_at_startup = 1
let g:mucomplete#completion_delay = 200
let g:mucomplete#reopen_immediately = 0
let g:mucomplete#buffer_relative_paths = 1
set completeopt+=menuone,noselect

" Quickfix
let g:qf_mapping_ack_style = 1
let g:qf_window_bottom = 0
let g:qf_loclist_window_bottom = 0

" read .vimrc.local
if filereadable(expand("~/.vimrc.local"))
    source ~/.vimrc.local
endif
